% vim: ts=4 sts=4 sw=4 et tw=75
\chapter{Debugging}
\label{chap:debug}
\begin{quote}
    Bug, a defect or fault in a machine, plan, or the like. orig.U.S. 1889
    Pall Mall Gaz. 11 Mar: 1/1 Mr. Edison, I was informed, has been up the
    two previous nights discovering 'a bug' in his phonograph -- an
    expression for solving a diffculty, implying that some imaginary insect
    has secreted itself inside and is causing all the trouble.
\end{quote}

\begin{quotesrc}
    \bookname{Oxford English Dictionary. 2nd Edition}
\end{quotesrc}

We have presented a lot of code in the past four chapters, and we've
pretended that it all pretty much worked the first time. Naturally this
wasn't ture; there were plenty of bugs. The word "bug" didn't originate
with programmers, but it is certainly one of the most common terms in
computing. Why should software be so hard?

One reason is that the complexity of a program is related to the number of
ways that its components can interact, and software is full of components
and interactions. Many techniques attempt to reduce the connections between
components so there are fewer pieces to interact; examples include
information hiding, abstraction and interfaces, and the language features
that support them. There are also techniques for ensuring the integrity of
a software design -- program proofs, modeling, requirements analysis,
formal verification -- but none of these has yet changed the way software
is built; they have been successful only on small problems. The reality is
that there will always be errors that we find by testing and eliminate by
debugging.

Good programmers know that they spend as much time debugging as writing so
they try to learn from their mistakes. Every bug you find can teach you how
to prevent a similar bug from happening again or to recognize it if it
does.

Debugging is hard and can take long and unpredictable amount of time, so
the goal is to avoid having to do much of it. Techniques that help reduce
debugging time include good design, good style, boundary condition tests,
assertions (断言) and sanity (完整性) checks in the code, defensive
(防御性) programming, well-designed interfaces, limited global data, and
checking tools. An ounce (盎司) of prevention really is worth a pound (磅)
of cure.

What is the role of language? A major force in the evolution of programming
language has been the attempt to prevent bugs through language features.
Some features make classes of errors less likely: range checking on
substript, restricted pointers or no pointers at all, garbage collection,
string data types, typed UO, and strong type-checking. On the opposite side
of the coin, some features are prone (倾向的) error, like \verb'goto'
statements, global variables, unrestricted pointers, and automatic type
conversions. Programmers should know the potentially risky bits of their
languages and take extra care when using them. They should also enable all
compiler checks and heed (注意) warnings.

Each language feature that prevents some problem has a cost of its own. If
a higher-level language makes the simple bugs disappear automatically, the
price is that it makes it easier to create higher-level bugs. No language
prevents you from making mistakes.

Even though we wish it were otherwise, a majority of programming time is
spent testing and debugging. In this chapter, we'll discuss how to make
your debugging time as short and productive as possible; we'll come back to
testing in Chapter \ref{chap:testing}.

\section{Debuggers}
\label{sec:debuggers}
Compiler for major languages usually come with sophisticated (复杂的)
debuggers, often packaged as part of a development environment that
integrates creation and edition of source code, compilation, execution, and
debugging, all in a single system. Debuggers include graphical interfaces
for stepping through a program one statement or function at a time,
stopping at particular lines or when a specific condition occurs. They also
provide facilities for formatting and displaying the values of variables.

A debugger can be invoked directly when a problem is known to exist. Some
debuggers take over automatically when something unexpectedly goes wrong
during program execution. It's usually easy to find out where the program
was executing when it died, examing the sequence of functions that were
active (the stack trace), and display the values of local and global
variables. That much information may be sufficient to identify a bug. If
not, breakpoints and stepping make it possible to re-run a failing program
one step at a time to find the first place where something goes wrong.

In the right environment and in the hands of an experienced user, a good
debugger can make debugging effective and efficient, if not exactly
painless. With such powerful tools at one's disposal, why would anyone ever
debug without them? Why do we need a whole chapter on debugging?

There are several good reasons, some objective and some based on personal
experience. Some languages outside the mainstream have no debugger or
provide only rudimentary (基本的) debugging facilities. Debuggers are
system-dependent, so you may not have access to the familiar debugger from
one system when you work on another. Some programs are not handled well by
debuggers: multi-process or multi-thread programs, operating systems, and
distributed systems must often be debugged by lower-level approaches. In
such situations, you're on your own, without much help besides print
statements and your own experience and ability to reason about code.

As a personal choice, we tend not to use debuggers beyond getting a stack
trace or the value of a variable or two. One reason is that it is easy to
et lost in details of complicated data structures and control flow; we find
stepping through a program less productive than thinking harder and adding
out statements and self-checking code at critical places. Clicking over
statements takes longer than scanning the output of judiciously-placed
(精心放置的) displays. It takes less time to decide where to put print
statements than to single-step to the critical section of code, even
assuming we know where that is. More important, debugging statements stay
with the program; debugger sessions are transient.

Blind probing with a debugger is not likely to be productive. It is more
helpful to use the debugger to discover the state of the program when it
fails, then think about how the failure could have happened. Debuggers can
be arcane (晦涩难解的) and diffcult programs, and especially for beginners
may provide more confusion than help. If you ask the wrong question, they
will probably give you an answer, but you may not know it's misleading.

A debugger can be of enormous (庞大的) value, however, and you should
certainly include one in your debugging toolkit; it is likely to be the
first thing you turn to. But if you don't have a debugger, or if you're
stuck on an especially hard problem, the techniques in this chapter will
help you to debug effectively and efficiently anyway. They should make your
use of your debugger more productive as well, since they are largely
concerned with how to reason about errors and probable causes.

\section{Good Clues, Easy Bugs}
Oops! Something is badly wrong. My program crashed, or printed nonsense, or
seems to be running forever. Now what?

Beginners have a tendency to blame the compiler, the library, or anything
other than their own code. Experienced programmers would love to do the
same, but they know that, realistically, most problems are their own fault.

Fortunately, most bugs are simple and can be found with simple techniques.
Examine the evidence in the erroneous output and try to infer (推论) how it
could have been produced. Look at any debugging output before the crash; if
possible get a stack trace from a debugger. Now you know something of what
happened, and where. Pause to reflect. How could that happen? Reason back
from the state of the crashed program to determine what could have caused
this.

Debugging involves backwards reasoning, like solving murder mysteries.
Something impossible occurred, and the only solid information is that it
really did occur. So we must think backwards from the result to discover
the reasons. Once we have a full explanation, we'll know what to fix and,
along the way, likely discover a few other things we hadn't expected.

\emph{Look for familiar patterns.} Ask yourself whether this is familiar
pattern. "I've senn that before" is often the beginning of understanding,
or even the whole answer. Common bugs have distinctive signatures. For
instance, novice (新手) C programmers often write:
\begin{badcode}
    int n;
    scanf("%d", n);
\end{badcode}
instead of 
\begin{wellcode}
    int n;
    scanf("%d", &n);
\end{wellcode}
ans this typically causes an attempt to access out-of-bounds memory when a
line of input is read. People who teach C recognize the symptom instantly.

Mismatched types and conversion in \verb'printf' and \verb'scanf' are an
endless source of easy bugs:
\begin{badcode}
    int n = 1;
    double d = PI;
    printf("%d %f\n", d, n);
\end{badcode}
The signature of this error is sometimes the appearance of preposterous
(反常的) values: huge integers or improbably large or small floating-point
values. On a Sun SPARC, the output from this program is a huge number and
% XXX The hyperlink of footnote doesn't response when click.
an astronomical (天文的) one\footnote{It's hard to type a long number, so I
    omit most of digits.} (folded to fit):
\begin{wellcode}
    107434034 26815 ... 30144.000000
\end{wellcode}

Another common error is using \verb'%f' instead of \verb'%lf' to read a
\verb'double' with \verb'scanf'. Some compilers catch such mistakes by
verifying that the type of \verb'scanf' and \verb'printf' arguments match
their format string; if all warnings are enabled. for the \verb'printf'
above, the GNU compiler gcc reports that 
\begin{wellcode}
    x.c:9: warning: int format, double arg (arg 2)
    x.c:9: warning: double format, different type arg (arg 3)
\end{wellcode}

Failing to initialize a local variable give rise to another distinctive
error. The result often an extremely large value, the garbage left over
from whatever previous value was stored in the same memory location. Some
compilers will warn you, though you may have enable the compile-time check,
and they can never catch all cases. Memory returned by allocators like
\verb'malloc', \verb'realloc', and \verb'new' is likely to be garbage too;
be sure to initialize it.

\emph{Examine the most recent change.} What was the last change? If you're
changing only one at a time as a program evolves, the bug most likely is
either in the new code or has been exposed by it. Looking carefully at
recent changes helps to localize the problem. If the bug appears in the new
version and not in the old, the new code is part of the problem. This means
that you should preserve at least the previous version of the program,
which you believe to be correct, so that you can compare behaviors. It also
means that you should keep records of the changes made and bugs fixed, so
you don't have to redicover this vital information while you're trying to
fix a bug. Source code control systems and other history mechanisms are
helpful here.

\emph{Don't make the same mistake twice.} After you fix a bug, ask whether
you might have made the same mistake somewhere else. This happened to one
of us just days before beginning to write this chapter. The program was a
quick prototype for a colleague, and included some boilerplate (样板) for
optional arguments:
\begin{badcode}
    for (i = 1; i < argc; i++) {
        if (argv[i][0] != '-')  /* options finished */
            break;
        switch (argv[i][1]) {
        case 'o':           /* output filename */
            outname = argv[i];
            break;
        case 'f':
            from = atoi(argv[i]);
            break;
        case 't':
            to = atoi(argv[i]);
            break;
        ...
\end{badcode}
Shortly after our colleague tried it, he reported that the output file name
always had the prefix \verb'-o' attached to it. This was embarrassing but
easy to repair; the code should have read 
\begin{wellcode}
    outname = &argv[i][2];
\end{wellcode}
So that was fixed up and shipped off, and back came another report that the
program failed to handle an argument like \verb'-f123' properly: the
converted numeric value was always zero. This is the same error; the next
case in the \verb'switch' should have read
\begin{wellcode}
    from = atoi(&argv[i][2]);
\end{wellcode}
Because the author was still in a hurry, he failed to notic that the same
blunder (错误) occurred twice more and it took another round before all of
the fundamentally identical errors were fixed.

Easy code can have bugs if its familiarity causes us to let down our guard.
Even when code is so simple you could write it in your sleep, don't fall
asleep while writing it.

\emph{Debug it now, not later.} Being in too much of a hurry can hurt in
other situations as well. Don't ignore a crash when it happens; track it
down right away, since it may not happen again until it's too late. A
famous example occurred on the Mars Pathfinder mission. After the flawless
(完美的) landing in July 1977 the spacecraft's computers tended to reset
once a day or so, and the engineer were baffled (困惑). Once they tracked
down the problem, they realized that they had seed that problem before.
During pre-launch tests the resets had occurred, but had been ignored
because the engineers were working on unrelated problems. So they were
forced to deal with the problem later when the machine was tens of millions
of miles away and much harder to fix.

\emph{Get a stack trace.} Although debuggers can probe running programs,
one of their most common uses is to examing the state of a program after
death. The source line number of the failure, often part of a stack trace,
is the most useful single piece of debugging information; improbable
(不太可能的) values of arguments are also a big clue (zero pointers,
integers that are huge when they should be small, or negative when they
should be positive, character strings that aren't alphabetic).

Here is a typical example, based on the discussion of sorting in Chapter
\ref{chap:alds}. To sort an array of integers, we should call \verb'qsort'
with the integer comparison function \verb'icmp':
\begin{wellcode}
    int arr[N];
    qsort(arr, N, sizeof(arr[0]), icmp);
\end{wellcode}
but suppose it is inadvertently (粗心地) passed the name of the string
comparison function \verb'scmp' instead:
\begin{badcode}
    int arr[N];
    qsort(arr, n, sizeof(arr[0]), scmp);
\end{badcode}
A compiler can't detect the mismatch of types here, so disaters awaits.
When we run the program, it crashes by attempting to access an illegal
memory location. Running the \verb'dbx' debugger producess a stack trace
% XXX The hyperlink of footnote doesn't response when click.
like this, edited to fit\footnote{The source pdf is blurry (模糊的), so the
    stack trace may contain some typing errors}:
\begin{wellcode}
    0 strcmp(0x1a2, 0x1c2) ["strcmp.s":31]
    1 scmp(p1 = 0x10001048, p2 = 0x1000105c) ["badqs.c":31]
    2 qst(0x10001048, 0x10001074, 0x400b20, 0x4) ["qsort.c":147]
    3 qsort(0x10001048, 0x1c2,0x4, 0x400b20) ["qsort.c",63]
    4 main() ["badqs.c":45]
    5 __istart() ["crtltinit.s":13]
\end{wellcode}
This says that the program died in strcmp; by inspection, the two pointers
passed to \verb'strcmp' are much too small, a clear sign of trouble. The
stack trace gives a trail (痕迹) of line numbers where each function was
called. Line 13 in our test file \verb'badqs.c' is the call 
\begin{wellcode}
    return strcmp(v1, v2);
\end{wellcode}
which identifies the failing call and points towards the error.

A debugger can also be used to display values of local or global variables
that will give additional information about what went wrong.

\emph{Read before typing.} One effective but under-appreciated debugging
technique is to read the code very carefully and think about it for a while
without making changes. There's a powerful urge to get to the keyboard and
start mofitying the program to see if the bug goes away. But chances are
that you don't know what's really broken and will change the wrong thing,
perhaps breaking something something else. A listing of the cirtical part
of program on paper can give a different perspective than what you see on
the screen, and encourages you to take more time for reflection. Don't make
listings as a matter of routine, though. Printing a complete program wastes
trees since it's hard to see the structure when it's spread across many
pages and the listing will be obsolete (荒废的) the moment you start
editing again.

Take a break for while; sometimes what you see in the source code is what
you meant rather than what you wrote, and an interval away from it can
soften your misconception (误解) and help the code speak for itself when
you return.

Resist the urge to start typing; thinking is a worthwhile alternative.

\emph{Explain your code to someone else.} Another effective technique is to
explain your code to someone else. This will often cause you to explain the
bug to yourself. Sometimes it takes no more than a few sentences, followed
by an embarrassed "Never mind, I see what's wrong. Sorry to bother you."
This works remarkably well; you can even use non-programmer as listeners.
One university computer center kept a teddy bear near the help desk.
Students with mysterious bugs were required to explain to the bear before
they could speak to a human counselor (顾问).

\section{No Clues, Hard Bugs}
"I haven't got a clue. What on earth is going on?" If you really haven't
any idea what could be wrong, life get tougher.

\emph{Make the bug reproducible.} The first step is to make sure you can
make the bug appear on demand. It's frustrating to chase down a bug that
doesn't happen every time. Spend some time construting input and parameter
settings that reliably cause the problem, then wrap up the recipe (处方) so
it can be run with a button push or a few keystrokes. If it's a hard bug,
you'll be making it happen over and over as you track down the problem, so
you'll save yourself time by making it easy to reproduce.

If the bug can't be made to happen every time, try to understand why not.
Does some set of conditions make it happen more often than others? Even if
you can't make it happen every time, if you can decrease the time spent
waiting for it, you'll find it faster. 

If a program provides debugging output, enable it. Simulation program like
the Markov chain program in Chapter \ref{chap:desipl} should include an
option that produces debugging information such as the seed of the random
number generator so that output can be reproduced; another option should
allow for setting the seed. Many programs include such options and it is a
good idea to include similar facilities in your own programs.

\emph{Divide and conquer (分而治之).} Can the input that causes the program
to fail be made smaller or more focused? Narrow down the possibilities by
creating the smallest input where the bug still shows up. What changes make
the error go way? Try to find crucial (决定性的) test cases that focus on
the error. Each test case should aim at a definitive outcome that confirms
or denies hypotheses (假说) about what is wrong.

Proceed by binary search. Throw away half the input and see if the output
is still wrong; if not, go back to the previous state and discard the other
half of the input. The same binary search process can be used on the proram
text itself: eliminate some part of the program that should have no
relationship to the bug and see if the bug is still there. An editor with
undo is helpful in reducing big test cases and big programs without losing
the bug.

\emph{Study the numerology (命理) of failures.} Sometimes a pattern in the
numerology of failing examples give a clue that focues the search. We found
some spelling mistakes in a newly written section of this book, where
occasional letters had simply disappeared. this was mystifying (迷惑的).
The text had been created by cutting and pasting from another file, so it
seemed possible that something was wrong with the cut or paste commands in
the text editor. But where to start looking for the problem? For clues we
looked at the data, and noticed that the missing characters seemed
uniformly (均匀地) distributed through the text. We measured the intervals
and found that the distance between dropped characters was always 1023
bytes, a suspiciously non-random value. A search through the editor source
code for numbers near 1024 found a couple of candidates. One of those was
in new code, so we examined that first, and the bug was easy to spot, a
classic off-by-one error where a null byte overwrote the last character in
a 1024-byte buffer.

Studying the patterns of numbers related to the failure pointed us right at
the bug. Elapsed time? A couple of minutes of mystification, five minutes
of looking at the data to discover the pattern of missing characters, a
minute to search for likely places to fix, and another minute to identify
and eliminate the bug. This one would have ben hopeless to find with a
debugger, since it involved two multiprocess programs, driven by mouse
clicks, communicating through a file system.

\emph{Display output to localize your search.} If you don't understand what
the program is doing, adding statements to display more information can be
the easiest, most cost-effective way to find out. Put them in to verify
your understanding or refine your ideas of what's wrong. For example,
diplay "can't get here" if you think it's not possible to reach a certain
point in the code; then if you see that message, move the output statements
back towards the start to figure out where things first begin to go wrong.
Or show "got here" messages going forward, to find the last place where
things seem to be working. Each message should be distinct so you can tell
which one you're looking at.

Display messages in a compact fixed format so they are easy to scan by eye
or with programs like the pattern-matching tool \verb'grep'. (A grep-like
program is invaluabe (无价的) for searching text. Chapter
\ref{chap:notation} includes a simple implementation.) If you're displaying
the value of a variable, format it the same way each time. In C and C++,
show pointers as hexadecimal numbers with \verb'%x' or \verb'%p'; this will
help you to see whether two pointers have the same value or are related.
Learn to read pointer values and recognize likely and unlikely ones, like
zero, negative numbers, odd numbers, and small numbers. Familiarity with
the form of address will pay off (获益) when you're using a debugger, too.

If output is potentially voluminous (长篇的), it might be sufficient to
print single-letter outputs like \verb'A', \verb'B', \verb'...', as a
compact display of where the program went.

\emph{Write self-checking code.} If more information is needed, you can
write your own check function to test a condition, dump relevant variables,
and abort the programs:
\begin{wellcode}
    /* check: test condition, print and dir */
    void check(char *s)
    {
        if (var1 > var2) {
            printf("%s, var1 %d var2 %d\n", s, var1, var2);
            fflush(stdout); /* make sure all output is out */
            abort();        /* signal abnormal termination */
        }
    }
\end{wellcode}
We wrote \verb'check' to call \verb'abort', a standard C library function
that causes program execution to be terminated abnormally for analysis with
a debugger. In a different application, you might want \verb'check' to
carry on after printing.

Next, add calls to \verb'check' wherever they might be useful in your code:
\begin{wellcode}
    check("before suspect");
    /* ... suspect code ... */
    check("after suspect");
\end{wellcode}

After a bug is fixed, don't throw \verb'check' away. Leave it in the
source, commented out or controlled by a debugging option, so that it can
be turned on again when the next difficult problem appears.

For harder problems, \verb'check' might evolve to do verification and
display of data structures. This approach can be generalized to routine
that perform ongoing (进行中) consistency checks of data structures and
other information. In a program with intricate (复杂的) data structures,
it's good idea to write these checks \emph{before} problems happen, as
components of the program proper (适当的), so they can be turned on when
trouble starts. Don't use then only when debugging; leave them installed
during all stages of program development. If they're not expensive, it
might be wise to leave them always enables. Large programs like telephone
switching systems often devote a significant amount of code to "audit"
(审计) subsystems that monitor information and equipment, and report or
even fix problems if they occur.

\emph{Write a log file.} Another tactic (策略) is to write a \emph{log
    file} containing a fixed-format stream of debugging output. When a
crash occurs, the log records what happened just before the crash. Web
servers and other network programs maintain extensive logs of traffic so
they can monitor themselves and their clients; this fragment (edited to
fit) comes from a local system:
\begin{wellcode}
    [Sun Dec 27 16:19:24 1998]
    HTTPd: access to /usr/local/httpd/cgi-bin/test.html
        failed for m1.cs.bell-labs.com,
        reason: client denied by server (CGI non-executable)
        from http://m2.cs.bell-labs.com/cgi-bin/test.pl
\end{wellcode}

Be sure to flush I/O buffers so the final log records appear in the log
file. Output functions like \verb'printf' normally buffer their output to
print it efficiently; abnormal termination may discard this buffered
output. In C, a call to \verb'fflush' guarantees that all output is written
before the program dies; there are analogous \verb'flush' function for
output streams in C++ and Java. Or, if you can afford the overhead, you can
avoid the flushing problem altogether by using unbuffered I/O for log
files. The standard functions \verb'setbuf' and \verb'setvbuf' control
buffering; \verb'setbuf(fp, NULL)' turns off buffering on the stream
\verb'fp'. The standard error streams (\verb'stderr', \verb'cerr',
\verb'System.err') are normally unbuffered by default.

\emph{Draw a picture}. Sometimes pictures are more effective than text for
testing and debugging. Pictures are especially helpful for understanding
data structures, as we say in Chapter \ref{chap:alds}, and of course when
writing graphics software, but they can be used for all kinds of programs.
Scatter (散点) plots display misplaced values more effectively than columns
of numbers. A histogram of data reveals anomalies in exam grades, random
numbers, bucket sizes in allocators and hash tables, and the like.

If you don't understand what's happening inside your program, try
annotating the data structures with statistics and plotting the result. The
% XXX The hyperlink of footnote doesn't response when click.
following graphs plot\footnote{Lack of graphs, because the graph is too
blurry and ugly to represent.}, for the C \verb'markov' program in Chapter
\ref{chap:desipl}, hash chain lengths on the $x$ axis and the number of
elements in chains of that length on the $y$ axis. The input data is our
standard test, \bookname{The Book of Psalms} (42685 words, 22482
prefixes). The first two graphs are for the good hash multipliers of 31 and
37 and the third is for the awful multiplier of 128. In the first two
cases, no chain is longer than 15 or 16 elements and most elements are in
chains of length 5 or 6. In the third, the distribution is broader, the
longest chain has 187 elements, and there are thousands of elements in
chains longer than 20.

\emph{Use tools.} Make good use of the facilities of the environment where
you are debugging. For example, a file comparison program like \verb'diff'
compares the outputs from successful and failed debugging runs so you can
focus on what has changed. If your debugging output is long, use
\verb'grep' to search it or an editor to examine it. Resist the temptation
to send the debugging output to a printer: computers scan voluminous output
better than people do. Use shell scripts and other tools to automate the
processing of the output from debugging runs.

Write trivial programs to test hypotheses or confirm your understanding of
how something works. For instance, is it valid to free a \verb'NULL' pointer?
\begin{wellcode}
    int main(void)
    {
        free(NULL);
        return 0;
    }
\end{wellcode}

Source code control programs like RCS keep track of versions of code so you
can see what has changed and revert to previous to restore a known state.
Besides indicating what has changed recently, they can identify sections of
code that have a long history of frequent modification; these are often a
good place for bugs to lurk (潜伏).

\emph{Keep records.} If the search for a bug goes on for any length of
time, you will begin to lose track of what you tried and what you learned.
If you record your tests and results, you are less likely to overlook
something or to think that you have checked some possibility when you
haven't. The act of writing will help you remember the problem the next
time something similar comes up, and will also serve when you're explaining
it to someone else.

\section{Last Resorts (手段)}
\label{sec:last_resorts}
What do you do if none of this advice help? This may be the time to use a
good debugger to step through the program. If your mental (精神上的) model
of how something works is just pain wrong, so you're looking in the wrong
place entirely, or looking in the right place but not seeing the problem, a
debugger forces you to think differently. These "mental model" bugs are
among the hardest to find; the mechanical aid is invaluabe.

Sometimes the misconception (误解) is simple: incorrect operator
precedence, or the wrong operator, or indentation that doesn't match the
actual structure, or a scope error where a local name hides a global name
or a global name introduces into a local scope. For example, programmers
often forget that \verb'&' and \verb'|' have lower precedence than
\verb'==' and \verb'!='. They write
\begin{badcode}
    if (x & 1 == 0)
        ...
\end{badcode}
and can't figure out why this is always false. Occasionally a slip of the
finger converts a single \verb'=' into two or vice versa:
\begin{badcode}
    while ((c == getchar()) != EOF)
        if (c = '\n')
            break;
\end{badcode}
Or extra code is left behind during editing:
\begin{badcode}
    for (i = 0; i < n; i++)
        a[i++] = 0;
\end{badcode}
Or hasty typing creates a problem:
\begin{badcode}
    switch (c) {
        case '<':
            mode = LESS;
            break;
        case '>':
            mode = GREATER;
            break;
        default:
            mode = EQUAL;
            break;
    }
\end{badcode}

Sometimes the error involes arguments in the wrong order in a situation
where type-checking can't help, like writing
\begin{badcode}
    memset(p, n, 0);    /* store n 0's in p */
\end{badcode}
instead of 
\begin{wellcode}
    memset(p, 0, n);    /* store n 0's in p */
\end{wellcode}

Sometimes something changes behind your back -- global or shared variables
are modified and you don't realize that some other routine can touch them.

Sometimes your algorithms or data structure has a fatal flaw (缺陷) and you
just can't see it. While preparing material on linked lists, we wrote a
package of list functions to create new elements, link them to the front or
back of lists, and so on; these functions appear in Chapter
\ref{chap:alds}. Of course we wrote a test program to make sure everything
was correct. The first few tests worked but then one failed spectacularly
(惊人地). In essence (基本), this was the testing program:
\begin{badcode}
    while (scanf(%s %d", name, &value) != EOF) {
        p = newitem(name, value);
        list1 = addfront(list1, p);
        list2 - addend(list2, p);
    }
    for (p = list1; p != NULL; p = p->next)
        printf("%s %d\n", p->name, p->value);
\end{badcode}
It was surprisingly difficult to see that the first loop was putting the
same node \verb'p' on both lists so the pointers were hopelessly scrambled
(扰乱) by the time we got to printing.

It's tough to find this kind of bug, because your brain takes you right
around the mistake. Thus a debugger is a help, since it forces you to go in
a different direction, to follow what the program is doing, not what you
think it is doing. Often the underlying problem is something wrong with the
structure of the whole program, and to see the error you need to return to
your starting assumptions.

Notice, by the way, that in the list example the error was in the test
code, which made the bug that much harder to find. It is frustratingly easy
to waste time chasing bugs that aren't there, because the test program is
wrong, or by testing the wrong version of the program, or by failing go
update or recompile before testing.

If you can't find a bug after considerable work, take a break. Clear your
mind, do something else. Talk to a friend and ask for help. The answer
might appear out of the blue, but if not, you won't be stuck in the same
rut (凹槽) in the next debugging session.

Once in a long while, the problem really is the compiler or a library or
the operating system or even the hardware, especially if something changed
in the environment just before a bug appeared. You should never start by
blaming one of these, but when everything else has been eliminated, that
might be all that's left. We once had to move a large text-formatting
program from its original Unix home to a PC.  The program compiled without
incident, but behaved in an extremely odd way: it dropped roughly every
second (次要的) character of its input. Our first thought was that this
must be some property of using 16-bit integers instead of 32-bit, or
perhaps some strange byte-order problem. But by printing out the characters
seen by the main loop, we finally tracked it down to an error in the
standard header file \verb'ctype.h' provided by the compiler vendor. It
implemented \verb'isprint' as a function macro:
\begin{badcode}
    #define isprint(c) ((c) >= 040 && (c) < 0177)
\end{badcode}
and the main input loop was basically
\begin{badcode}
    while (isprint(c = getchar()))
        ...
\end{badcode}

Each time an input character was blank (octal 40, a poor way to write ' ')
or greater, which was most of the time, \verb'getchar' was called a second
time because the macro evaluated its argument twice, and the first input
character disappeared forever. The original code was not as clean as it
should have been -- there's too much in the loop condition -- but the
vendor's header file was inexcusably (无法容许地) wrong.

One can still find instances of this problem today; this macor comes from a
different verdor's current header files:
\begin{badcode}
    #define __iscsym(c) (isalnum(c) || ((c) == '_'))
\end{badcode}

Memory "leaks" -- the failure to reclaim memory that is no longer in use --
are a significant source of erratic behavior. Another problem is forgetting
to close files, until the table of open files is full and the program
cannot open any more.  Programs with leaks tend to fail mysteriously
because they run out of some resource but the specific failure can't be
reproduced.

Occasionally hardware itself goes bad. The floating-point flaw (缺陷) in
the 1994 Pentium processor that caused certain computations to produce
wrong answers was a highly publicized (广为宣传的) and costly bug in the
design of the hardware, but once it had been identified, it was of course
reproducible.  One of the strangest bugs we ever saw involved a calculator
program, long ago on a two-processor system.  Sometimes the expression
$1/2$ would print $0.5$ and sometimes it would print some consistent but
utterly (完全) wrong value like $0.7432$; there was no pattern as to
whether one got the right answer or the wrong one. The problem was
eventually traced to a failure of the floating-point unit in one of the
processors. As the calculator program was randomly executed on one
processor or the other, answers were either correct or nonsense.

Many years ago we used a machine whose internal temperature could be
estimated from the number of low-order bits it got wrong in floating-point
calculations. One of the circuit cards was loose; as the machine got
warmer, the card tilted (倾斜的) further out of its socket, and more data
bits were disconnected from the backplane (基架).

\section{Non-reproducible Bugs}

Bugs that won't stand still are the most difficult to deal with, and
usually the prob- lem isn't as obvious as failing hardware. The very fact
that the behavior is non- deterministic is itself information, however; it
means that the error is not likely to be a flaw (缺陷) in your algorithm
but that in some way your code is using information that changes each time
the program runs.

Check whether all variables have been initialized; you may be picking up a
random value from whatever was previously stored in the same memory
location.  Local variables of functions and memory obtained from allocators
are the most likely culprits (罪魁祸首) in C and C++. Set all variables to
known values; if there's a random number seed that is normally set from the
time of day, force it to a constant, like zero.

If the bug changes behavior or even disappears when debugging code is
added, it may be a memory allocation error -- somewhere you have written
outside of allocated memory, and the addition of debugging code changes the
layout of storage enough to change the effect of the bug. Most output
functions, from \verb'printf' to dialog windows, allocate memory
themselves, further muddying the waters (进一步把水搅混).

If the crash site seems far away from anything that could be wrong, the
most likely problem is overwriting memory by storing into a memory location
that isn't used until much later. Sometimes this is a dangling (悬挂)
pointer problem, where a pointer to a local variable is inadvertently
(不慎地) returned from a function, then used. Returning the address of a
local variable is a recipe (秘诀) for delayed disaster:
\begin{badcode}
    char *msg(int n, char *s)
    {
        char buf[100];

        sprintf(buf, "error %d: %s\n", n, s);
        return buf;
    }
\end{badcode}
By the time the pointer returned by \verb'msg' is used, it no longer points
to meaningful storage. You must allocate storage with \verb'malloc', use a
static array, or require the caller to provide the space.

Using a dynamically allocated value after it has been freed has similar
symptoms. We mentioned this in Chapter \ref{chap:alds} when we wrote
\verb'freeall'. This code is wrong:
\begin{badcode}
    for (p = listp; p != NULL; p = p->next)
        free(p);
\end{badcode}
Once memory has been freed, it must not be used since its contents may have
changed and there is no guarantee that \verb'p->next' still points to the
right place.

In some implementations of \verb'malloc' and \verb'free', freeing an item
twice corrupts the internal data structures but doesn't cause trouble until
much later, when a subsequent call slips (滑过) on the mess made earlier.
Some allocators come with debugging options that can be set to check the
consistency of the arena (竞技场) at each call; turn them on if you have a
non-deterministic bug. Failing that, you can write your own allocator that
does some of its own consistency checking or logs all calls for separate
analysis. An allocator that doesn't have to run fast is easy to write, so
this strategy is feasible when the situation is dire (可怕的). There are
also excellent commercial products that check memory management and catch
errors and leaks: writing your own \verb'malloc' and \verb'free' can give
you some of their benefits if you don't have access to them.

When a program works for one person but fails for another, something must
depend on the external environment of the program. This might include files
read by the program, file permissions, environment variables, search path
for commands, defaults, or startup files. It's hard to be a consultant for
these situations, since you have to become the other person to duplicate
the environment of the broken program.

\begin{exercise}
Write a version of \verb'malloc' and \verb'free' that can be used for
debugging storage-management problems. One approach is to check the entire
workspace on each call of \verb'malloc' and \verb'free'; another is to
write logging information that can be processed by another program. Either
way, add markers to the beginning and end of each allocated block to detect
overruns (超限) at either end.
\end{exercise}
