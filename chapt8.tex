% vim: ts=4 sts=4 sw=4 et tw=75
\chapter{Portability}
\label{chap:portability}
\begin{quote}
    Finally, standardization, like convention, can be another manifestation
    (证明) of the strong older. But unlike convention it has been accepted
    in Modern architecture as an enriching (丰富) product of our
    technology, yet dreaded (可怕的) for its potential domination and
    brutality.
\end{quote}
\begin{quotesrc}
    Robert Venturi, \bookname{Complexity and Contradiction (矛盾) in
Architecture}
\end{quotesrc}

It's hard to write software that runs correctly and efficiently. So once a
program works in one environment, you don't want to repeat much of the
effort if you move it to a different compiler or processor or operating
system. Ideally (理想地), it should need no changes whatsoever (无论什么).

This ideal is called \emph{portability}. In practice, "portability" more
often stands for the weaker concept that it will be easier to modify the
program as it moves than to rewrite it from scratch (擦除). The less
revision it needs, the more portable it is.

You may wonder why we worry about portability at all. If software is going
to run in only one environment, under specified conditions, why spend time
giving it broader applicability? First, any successful program, almost by
definition, gets used in unexpected ways and unexpected places. Building
software to be more general than its original specification will result in
less maintenance and more utility down the road. Second, environments
change. When the compiler or operating system or hardware is upgraded,
features may change. The less the program depends on special features, the
less likely it is to break and the more easily it will adapt to changing
circumstances. Finally, and most important, a portable program is a better
program. The effort invested to make a program portable also makes it
better designed, better constructed, and more thoroughly tested. The
techniques of portable programming are closely related to the techniques of
good programming in general.

Of course the degree of portability must be tempered (调和) by reality.
There is no such thing as an absolutely portable program, only a program
that hasn't yet been tried in enough environments. But we can keep
portability as our goal by aiming towards software that runs without change
almost everywhere. Even if this goal isn't met completely, time spent on
portability as the program is created will pay off when the software must
be updated.

Our message is this: try to write software that works within the
intersection of the various standards, interfaces and environments it must
accommodate. Don't fix every portability problem by adding special code;
instead, adapt the software to work within the new constraints. Use
abstraction and encapsulation to restrict and control unavoidable
non-portable code. By staying within the intersection of constraints and by
localizing (局部化) system dependencies, your code will become cleaner and
more general as it is ported (移值).

\section{Language}
\label{sec:language}

\emph{Stick to the standard.} The first step to portable code is of course
to program in a high-level language, and within the language standard if
there is one.  Binaries don't port well, but source code does. Even so, the
way that a compiler translates a program into machine instructions is not
precisely defined, even for standard languages.  Few languages in wide use
have only a single implementation; there are usually multiple suppliers,
or versions for different operating systems, or releases that have evolved
over time. How they interpret your source code will vary.

Why isn't a standard a strict definition? Sometimes a standard is
incomplete and fails to define the behavior when features interact
(互相干扰). Sometimes it's deliberately (故意地) indefinite (不确定); for
example, the \verb'char' type in C and C++ may be signed or unsigned, and
need not even have exactly 8 bits. Leaving such issues up to the compiler
writer may allow more efficient implementations and avoid restricting the
hardware the language will run on, at the risk of making life harder for
programmers. Politics and technical compatibility issues may lead to
compromises that leave details unspecified.  Finally, languages are
intricate (复杂的) and compilers are complex; there will be errors in the
interpretation and bugs in the implementation.

Sometimes the languages aren't standardized at all. C has an official
ANSI/ISO standard issued in 1988, but the ISO C++ standard was ratified
(批准) only in 1998; at the time we are writing this, not all compilers in
use support the official definition. Java is new and still years away from
standardization. A language standard is usually developed only after the
language has a variety of conflicting (互相矛盾的) implementations to unify
(统一), and is in wide enough use to justify the expense of
standardization.  In the meantime, there are still programs to write and
multiple environments to support.

So although reference manuals and standards give the impression (印象) of
rigorous (严格的) specification, they never define a language fully, and
different implementations may make valid but incompatible interpretations.
Sometimes there are even errors. A small illustration showed up while we
were first writing this chapter. This external declaration is illegal in C
and C++:
\begin{badcode}
    *x[] = {"abc"};
\end{badcode}
A test of a dozen compilers turned up a few that correctly diagnosed the
missing \verb'char' type specifier for \verb'x', a fair number that warned
of mismatched types (apparently using an old definition of the language to
infer (推断) incorrectly that \verb'x' is an array of \verb'int' pointers),
and a couple that compiled the illegal code without a murmur (低语) of
complaint.

\emph{Program in the mainstream.} The inability of some compilers to flag
this error is unfortunate, but it also indicates an important aspect of
portability.  Languages have dark comers (死角) where practice varies --
bit-fields in C and C++, for example -- and it is prudent (谨慎的) to avoid
them. Use only those features for which the language definition is
unambiguous and well understood. Such features are more likely to be widely
available and to behave the same way everywhere. We call this the
mainstream of the language.

It's hard to know just where the mainstream is, but it's easy to recognize
constructions that are well outside it. Brand new features such as
\verb'//' comments and \verb'complex' in C, or features specific to one
architecture such as the keywords \verb'near' and \verb'far', are
guaranteed to cause trouble. If a feature is so unusual or unclear that to
understand it you need to consult a "language lawyer" -- an expert in
reading language definitions -- don't use it.

In this discussion, we'll focus on C and C++, general-purpose languages
commonly used to write portable software. The C standard is more than a
decade old and the language is very stable, but a new standard is in the
works, so upheaval (变动) is coming.  Meanwhile, the C++ standard is hot
off the press (刚刚出炉), so not all implementations have had time to
converge (聚合).

What is the C mainstream? The term usually refers to the established style
of use of the language, but sometimes it's better to plan for the future.
For example, the original version of C did not require function prototypes.
One declared \verb'sqrt' to be a function by saying
\begin{badcode}
    double sqrt();
\end{badcode}
which defines the type of the return value but not of the parameters. ANSI
C added function prototypes, which specify everything:
\begin{wellcode}
    double sqrt(double);
\end{wellcode}
ANSI C compilers are required to accept the earlier syntax, but you should
nonetheless (仍然) write prototypes for all your functions. Doing so will
guarantee safer code -- function calls will be fully type-checked -- and if
interfaces change, the compiler will catch them. If your code calls
\begin{wellcode}
    func(7, PI);
\end{wellcode}
but func has no prototype, the compiler might not verify that \verb'func'
is being called correctly. If the library later changes so that \verb'func'
has three arguments, the need to repair the software might be missed
because the old-style syntax disables type checking of function arguments.

C++ is a larger language with a more recent standard, so its mainstream is
harder to identify. For example, although we expect the STL to become
mainstream, this will not happen immediately, and some current
implementations do not support it completely.
