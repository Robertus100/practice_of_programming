% vim: ts=4 sts=4 sw=4 et tw=75
\chapter{Style}
\label{chap:style}
\begin{quote}
    It is an old observation that the best writers sometimes disregard the
    rules of rhetoric(修辞学). When they do so, however, the reader will
    usually find in the sentence some compensating(补偿) merit(优点),
    attained at the cost of the violation(违反). Unless he is centain of
    doing as well, he will probaly do best to follow the rules.
\end{quote}

\begin{quotesrc}
    William Strunk and E. B. White, \bookname{The Elements of Style}
\end{quotesrc}

This fragment of code comes from a large program written many years ago:
\begin{wellcode}
    if ((country == SING) || (country == BRNI) ||
        (country == POL) || (country == ITALY))
    {
        /*
         * If the country is Singapore, Brunei or Poland
         * then the current time is the answer time 
         * rather than the off hook time.
         * Reset answer time and set day of week.
         */
         ...
    }
\end{wellcode}

It's carefully written, formatted, and commented, and the program it comes
from works extremly well; the programmers who create these system are
rightly proud of what they built. But this except is puzzling to the casual
reader. What relationship links Singapore, Brunei, Poland and Italy? Why
isn't Italy mentioned in the comment? Since the comment and the code
differ, one of them must be wrong. Maybe both are. The code is what gets
executed and tested, so it's more likely to be right; probably the comment
didn't get updated when the code did. The comment doesn't say enough about
the relationship among the three countries it does mention; if you had to
maintain this code, you would need to know more.

The few lines above are typical of much real code: mostly well done, but
with some things could be improved.

This book is about te practice of programming -- how to write programs for
real. Our purpose is to help you to write software that works at least as
well as the program this example was take from, while avoiding trouble
spots and weakness. We will talk about writing better code from the
beginning and improving it as it evolves.

We are going to start in an unusual place, however, by discussing
programming style. The purpose of style is to make the code easy to read
for yourself and others, and good style is curcial to good programming. We
want to talk about it first so you will be sensitive to it as you read the
code in the rest of the book.

These is more to writing a program than getting the syntax right, fixing
the bugs, and making it run fast enough. Programs are read not only by
computers but also by programmers. A well-written program is easier to
understand and to modify than a poorly-written one. The discipline of
writing well leads to code that is more like to be correct. Fortunately,
this discipline is not hard.

The principles of programming style are based on common sense guided
experience, not on arbitrary rules and prescriptions(命令). Code should be
clear and simle -- straightforward login, natural expression, conventional
language use, meaningful names, neet formatting, helpful comments -- and it
should be avoid clever tricks and unusual constructions. Consitency is
important because others will find it easier to read your code, and you
theirs, if you all stick to the same style. Detail many be imposed by local
conventions, management edict(法令), or a program, but even if not, but if
even not, it is best to obey a set of widely shared conventions. We follow
the style used in the book \bookname{The C Programming Language}, with
minor adjustments for C++ and Java.

We will often illustrate rules of style by small example of bad and good
programming, since the contrast between two ways of saying the same thing
is instructive. These example are not artifical. The "bad" ones are all
adapted from real code, written by ordinary programmers(occasionally
yourselves) working under the common pressures of too much work and too
little time. Some will be distilled(提取) for brevity(简短), but they will
not be misrepresented(错误的叙述). Then we will rewrite the bad
excerpts(摘录) to show how they could be improved. Since they are real
code, however, they may exhibit(展现) multiple problems. Addressing every
shortcoming would take us too far off topics, so some of the good examples
will still harbor(隐藏) other, unremarked flaws(缺点).

To distiguish bad examples from good, throughout the book we will place
question marks in the questionable code, as in this real excerpt(摘录):
\begin{badcode}
    #define ONE 1
    #define TEN 10 
    #define TWENTY  20
\end{badcode}
Why are these \verb"#define"s questionable? Consider the modification that
will be necessary if an array of \verb"TWENTY" elements must be made
larger. At the very least(至少), each name should be replaced by one that
indicates the role of the specific value in the program:
\begin{wellcode}
    #define INPUT_MODE  1
    #define INPUT_BUFSIZE   10
    #define OUTPUT_BUFSIZE  20 
\end{wellcode}

\section{Names}
\label{sec:names}
What's in a name? A variable or function name labels an object and conveys
information about its purpose. A name should be informative, concise,
memorable, and pronounceable if possible. Much information coomes from
context and scope; the broader the scope of a variable, the more
information should be conveyed by it's name.

\emph{Use descriptive names for globals, short names for locals.} Global
variables, by definition, can crop up(突然出现) anywhere in a program, so
they need names long enough and descriptive enough to remind the reader of
their meaning. It's also helpful to include a brief comment with the
declaration of each global:
\begin{wellcode}
    int npending = 0;   // current length of input queue
\end{wellcode}
Global functions, classes and structures should also have descriptive names
that suggest their role in a program.

By contrast, shorter names suffice(足够) for local variables; within a
function, \verb"n" may be sufficient, \verb"npoints" is fine, and
\verb"numberOfPoints" is overkill.

Local variables used in conventional way can have very short names. The use
of \verb"i" and \verb"j" for loop indices, \verb"p" and \verb"q" for
pointers, and \verb"s" and \verb"t" for strings is so frequent that there
is little profit and perhaps some loss in longer names. Compare
\begin{badcode}
    for (theElementIndex = 0; theElementIndex < numberOfElements;
            theElementIndex++)
        elementArray[theElementIndex] = theElementIndex;
\end{badcode}
to 
\begin{wellcode}
    for (i = 0; i < nelems; i++)
        elem[i] = i;
\end{wellcode}
Programmers are often encouraged to use long variable names regardless of
context. That is s mistake: clarity is often achieved through brevity.

There are many naming convensions and local customs. Common ones include
using names that begin or end with \verb"p", such as \verb"nodep", for
pointer; initial capital letters for \verb"Global"s; and all capital for
\verb"CONSTANT"s. Some programming shop use more sweeping(彻底的) rules,
such as notation to encode type and usage information in the variable,
perhaps \verb"pch" to mean a pointer to a character and \verb"strTo" and
\verb"strFrom" to mean strings that will be written to and read from. As
for the spelling of the names themselves, whether to use \verb"npending" or
\verb"numPending" or \verb"num_pending" is a matter of taste; specific
rules are much less important than consistent adherence(坚持) to a sensible
convention.

Naming conventions make it easier to understand your own code, as well as
code written by others. They also make it easier to invent new names as the
code is being written. The longer the program, the more important is the
choice of good, descriptive, systematic names.

Namespaces in C++ and packages in Java provide ways to manage the scope of
names and help to keep meanings clear without unduly(过度的) long names.

\emph{Be consistent.} Give related things related names that show their
relationshipt and highlight their difference.

Besides beging much too long, the member names in this Java class are
wildly(鲁莽地) inconsistent:
\begin{badcode}
    class UserQueue {
        int noOfItemsInQ, frontOfTheQueue, queueCapacity;
        public int noOfUserInQueue() { ... }
    }
\end{badcode}
The word "queue" appears as Q, Queue and queue. But since queues can only
be accessed from a variable of type \verb"UserQueue", member names do not
need to mention "queue" at all; context suffices, so 
\begin{badcode}
    queue.queueCapacity
\end{badcode}
is redundant. This version is better:
\begin{wellcode}
    class UserQueue {
        int nitems, front, capacity;
        public int nusers() { ... }
    }
\end{wellcode}
since it leads to statements like 
\begin{wellcode}
    queue.capacity++;
    n = queue.nusers();
\end{wellcode}
No clarity is lost. This example still needs work, however, "items" and
"users" are the same thing, so only one term should be used for a single
concept.

\emph{Use active names for functions.} Function names should be based on
active verbs, perhaps followed by nouns:
\begin{wellcode}
    now = data.getTime();
    putchar('\n');
\end{wellcode}
Functions that return boolean(true or false) value should be named so that
return value is unambiguous. Thus
\begin{badcode}
    if (checkoctal(c)) ...
\end{badcode}
does not indicate which value is true and which is false, while 
\begin{wellcode}
    if (isoctal(c)) ...
\end{wellcode}
makes it clear that the function return true if argument is octal and false
if not.

\emph{Be accurate.} A name not only labels, it conveys information to the
reader. A misleading names can result in mystifying(模糊的) bugs.

One of us wrote and distributed for years a macro called \verb"isoctal"
with this incorrect implementation:
\begin{badcode}
    #define isoctal(c) ((c) >= '0' && (c) <= '8')
\end{badcode}
instead of the proper
\begin{wellcode}
    #define isoctal(c) ((c) >= '0' && (c) <= '7')
\end{wellcode}
In this case, the name conveyed the correct intent but the implementation
was wrong; it's easy for a sensible name to disguise a broken
implementation.

Here is an example in which the name and the code are in complete
contradiction(矛盾):
\begin{badcode}
    public boolean inTable(Object obj) {
        int j = this.getIndex(obj);
        return(j == nTable);
    }
\end{badcode}

The function \verb"getIndex" returns a value between zero and
\verb"nTable-1" if it finds the object, and returns \verb"nTable" if not.
The boolean value returned by \verb"inTable" is thus the oppsite of what
the name implies. At the time code is written, this might not cause
trouble, but it the program is modified later, perhaps by a different
programmer, the name is sure to confuse.

\begin{exercise}
Comment on the choice of names and values in the following code.
\begin{badcode}
    #define TRUE    0
    #define FALSE   1

    if ((ch = getchar()) == EOF)
        not_eof = FALSE;
\end{badcode}
\end{exercise}

\begin{exercise}
Improve this function:
\begin{badcode}
    int smaller(char *s, char *t) {
        if (strcmp(s, t) < 1)
            return 1;
        else 
            return 0;
    }
\end{badcode}
\end{exercise}

\begin{exercise}
Read this code aloud:
\begin{badcode}
    if ((falloc(SMRHSHSCRTCH, S_IFEXT|0644, MAXRODDHSH)) < 0)
        ...
\end{badcode}
\end{exercise}

\section{Expression and Statements}
\label{sec:exprstat}
By analogy(类比) with choosing names to aid the reader's understanding,
write expressions and statements in a way that makes their meaning as
transport as possible. Write the clearest code that does the job. Use
spaces around operators to suggest grouping; more generally, format to help
readability. This is trivial(琐细的) but valuable, like keeping a neat dest
so you can find things. Unlike your dest, your programs are likely bo be
examined by others.

\emph{Indent to show structure.} A consistent indentation style is the
lowest-energy way to make a program's structure self-evident(不言自明的).
This example is badly formatted:
\begin{badcode}
    for(n++;n<100;field[n++]='\0');
    *i = '\0'; return('\n');
\end{badcode}
Reformatting improves it somewhat:
\begin{badcode}
    for (n++; n < 100; field[n++] = '\0')
        ;
    *i = '\0';
    return('\n');
\end{badcode}
Even better is to put the assignment in the body and separate the
increment, so the loop takes a more conventional form and is thus easier to
grasp(抓取):
\begin{wellcode}
    for (n++; n < 100; n++)
        field[n] = '\0';
    *i = '\0';
    return '\n';
\end{wellcode}
\emph{Use the natural form for expressions.} Write expressions as you might
speak them aloud. Conditional expressions that include negations are always
hard to understand:
\begin{badcode}
    if (!(block-id < actblks) || !(block-id >= unblocks))
        ...
\end{badcode}
Each test is stated negatively, though there is no need for either to be.
Turing the relations around lets us state the tests positively:
\begin{wellcode}
    if ((block-id >= actblks) || (block - id < unblocks))
        ...
\end{wellcode}
Node the code reads naturally.
\emph{Parenthesize to resolves ambiguity.} Parentheses specify grouping and
can be used to make the intent clear event when they are not required. The
inner parentheses in the previous example are not necessary, but they don't
hurt, either. Seasoned(经验丰富的) programmers might omit them, because the
relational operators(\verb"< <= == != >= >") have higher precedence than
the locgical operators(\verb"&&" and \verb"||").

When mixing unrelated oprators, though, it's a good idea to parenthesize. C
and it's friends present pernicious(恶劣的) precedence problems, and it's
easy to make a mistake. Because the logical operators bind tighter than
assignment, parentheses are mandatory for most expressions that combine them:
\begin{wellcode}
    while ((c = getchar()) != EOF)
        ...
\end{wellcode}
The bitwise operators \verb"&" and \verb"|" have lower precedence than
relational operators like \verb"==", so despite it's appearance,
\begin{badcode}
    if (x&MASK == BITS)
        ...
\end{badcode}
actually means
\begin{badcode}
    if (x & (MASK==BITS))
        ...
\end{badcode}
which is centainly not the programmer's intent. Because it combines bitwise
and relational operators, the expression need parentheses:
\begin{wellcode}
    if ((x&MASK) == BITS)
        ...
\end{wellcode}
Even if parentheses aren't necessary, they can help if the grouping is hard
to grasp at first glance. This code doesn't need parentheses:
\begin{badcode}
    leap_year = y % 4 == 0 && y % 100 != 0 || y % 400 == 0;
\end{badcode}
but they make it easier to understand:
\begin{wellcode}
    leap_year = ((y%4 == 0) && (y%100 != 0)) || (y%400 == 0);
\end{wellcode}
We also removed some of the blanks: grouping the operands of
higher-precendence operators helps the readers to see the structure more
quickly.

\emph{Break up complex expressions.} C, C++ and Java have rich expression
syntax and operators, and it's easy to get carried away by cramming(塞满)
everything into one construction. An expression like the following is
compact(紧凑的) but it packs too many oprations into a single statement:
\begin{badcode}
    *x += (*xp=(2*k < (n-m) ? c[k+1] : d[k--]));
\end{badcode}
It's easier to grasp when broken into several pieces:
\begin{wellcode}
    if (2*k < n-m)
        *xp = c[k+1];
    else 
        *xp = d[k--];
    *x += *xp;
\end{wellcode}
\emph{Be clear.} Programmers' endless creative energy is sometimes used to
write the most concise code possible, or to find clever ways to achieve a
result. Sometimes these skills are misapplied, though, since the goal is to
write clear code, not clever code.

What does this intricate(复杂的) calculation do?
\begin{badcode}
    subkey = subkey >> (bitoff - ((bitoff >> 3) << 3));
\end{badcode}
The innermost expression shifts \verb"bitoff" three bits to the right. The
result is shifted left again, thus replacing the three shifted bits by
zeros. This result in turn is subtracted from the original value, yielding
the bottom three bits of \verb"bitoff". These three bits are used to shift
\verb'subkey' to the right.

Thus the original expression is equivalent to 
\begin{wellcode}
    subkey = subkey >> (bitoff & 0x7);
\end{wellcode}
It takes a while to puzzle out what the first version is doing; the second
is shorter and clearer. Experienced programmers make it ever shorter by
using assignment operator:
\begin{wellcode}
    subkey >>= bitoff & 0x7;
\end{wellcode}
Some constructs seem to invite abuse. The \verb"?:" operator can lead to
mysterious code:
\begin{badcode}
    child=(!LC&&!RC)?0:(!LC?RC:LC);
\end{badcode}
It's almost impossible to figure out what this code without following all
the possible paths through the expression. This form is longer, but much
easier to follow because it makes the paths explicit:
\begin{wellcode}
    if (LC == 0 && RC == 0)
        child = 0;
    else if (LC == 0)
        child = RC;
    else
        child = LC;
\end{wellcode}
The \verb'?:' operator is fine for short expressions where it can replace
four lines of if-else with one, as in
\begin{wellcode}
    max = (a > b) ? a : b;
\end{wellcode}
or perhaps
\begin{wellcode}
    printf("The list has %d item%s\n", n, n==1 ? "" : "s");
\end{wellcode}
but it is not a general replacement for conditional statements.

\emph{Be careful with side effect.} Operators like \verb'++' have side
effects: besides returning a value, they also modify an underlying
variable. Side effects can be extremely convenient, but they can also cause
trouble because the actions of retrieving the value and updating the
variable might not happen at the same time. In C and C++, the order of
execution of side effects is undefined, so this multiple assignment is
likely to produce the wrong answer:
\begin{badcode}
    str[i++] = str[i++] = ' ';
\end{badcode}
The intent is to store blanks at the next two position in \verb'str'. But
depending on when \verb'i' is updated, a position in \verb'str' could be
skipped and \verb'i' might end up increased only by 1. Break it into two
statements:
\begin{wellcode}
    str[i++] = ' ';
    str[i++] = ' ';
\end{wellcode}

Even though it cantains only one increment, this assignment can also give
varying results:
\begin{badcode}
    array[i++] = i;
\end{badcode}
If \verb'i' is initially 3, the array element might be set to 3 or 4.

It's not just increment and decrement that have side effects; I/O is
another source of behind-the-scenes(幕后的) action. This example is an
attempt to read two related numbers from standard input:
\begin{badcode}
    scanf("%d %d", &yr, &profit[yr]);
\end{badcode}
It is broken because part of the expression modifies \verb'yr' and another
part uses it. The value of \verb'profit[yr]' can never be right unless the
new value of \verb'yr' is the same as the old one. You might think that the
answer depends on the order in which the arguments are evaluated, but the
real issue is that all the arguments to \verb'scanf' are evaluated before
the routine is called, so \verb'&profit[yr]' will always be evaluated using
the old value of \verb'yr'. This sort of problem can occur in almost any
language. The fix is, as usual, to break up the expression:
\begin{wellcode}
    scanf("%d", &yr);
    scanf("%d", &profit[yr]);
\end{wellcode}
Exercises cantion in any expression with side effects.

\begin{exercise}
Improves each of these fragments:
\begin{badcode}
    if (!(c == 'y' || c == 'Y'))
        return;
    length = (length < BUFSIZE) ? length : BUFSIZE;
    flag = flag ? 0 : 1;
    quote = (*line == '"') ? 1 : 0;
    if (val & 1)
        bit = 1;
    else
        bit = 0;
\end{badcode}
\end{exercise}

\begin{exercise}
What is wrong with this excerpt(摘录)?
\begin{badcode}
    int read(int *ip) {
        scanf("%d", ip);
        return *ip;
    }
        ...
    insert(&graph[vert], read(&val), read(&ch));
\end{badcode}
\end{exercise}

\begin{exercise}
List all the different output this could produce with various
orders of evaluation:
\begin{badcode}
    n = 1;
    printf("%d %d\n", n++, n++);
\end{badcode}
Try it on as many compilers as you can, to see what happens in practice.
\end{exercise}

\section{Consistency and Idioms(习惯用法)}
\label{sec:consist_idom}
Consitency leads to better programs. If formatting varies unpredictably, or
loop over an array runs upill this time and downhill the next, or strings
are copied with \verb'strcpy' and a \verb'for' loop there, the variations
make it harder to see what's really going on. But if the same computation
is done the same way every time it appears, any variation suggests a
genuine(真正的) difference, one worth nothing.

\emph{Use a consistent indentation and brace style.} Indentation show
structure, but which indentation style is best? Should the opening brace go
one the same line as the \verb'if' for on the next? Programmers have always
argued about the layout of program, but the specific style is much less
important than its consistent application. Pick one style,
preferably(更合意地) ours, use it consistently, and don't waste time
arguing.

Should you include braces even when they are not needed? Like parentheses,
braces can resolve ambiguity and occasionally make the code clearer. For
consistency, many experienced programmers always put braces around loop
or \verb'if' bodies. But if the body is a single statement they are
unnecessary, so we tend to omit them. If you also choose to leave them out,
make sure you don't drop them when they are needed to resolve the
"dangling(悬挂的) else" ambiguity exemplified(示例) by this excerpt(摘录):
\begin{badcode}
    if (month == FEB) {
        if (year%4 == 0)
            if (day > 29)
                legal = FALSE;
        else 
            if (day > 28)
                legal = FALSE;
    }
\end{badcode}
The indentation is misleading, since the \verb'else' is actually attached
to the line 
\begin{badcode}
    if (day > 29)
\end{badcode}
and the code is wrong. When one \verb'if' immediately follows another,
always use braces:
\begin{badcode}
    if (month == FEB) {
        if (year%4 == 0) {
            if (day > 29)
                legal = FALSE;
        } else {
            if (day > 28)
                legal = FALSE;
        }
    }
\end{badcode}
Syntax-driven tools make this sort of mistake less likely.

Even with the bug fixed, though, the code is hard to follow. The
computation is easier to grasp if we use a variable to hold the number of
days in February:
\begin{badcode}
    if (month == FEB) {
        int nday;

        nday = 28;
        if (year%4 == 0)
            nday == 29;
        if (day > nday)
            legal = FALSE;
    }
\end{badcode}
The code still wrong -- 2000 is a leap year, while 1900 and 2100 are not --
but this structure is much easier to adapt to make it absolutely right.

By the way, if you work on a program you didn't write, preserve the style
you find there. When you make a change, don't use your own style even
though you prefer it. The program's consistency is more important than your
own, because it makes life easier for those who follow.

\emph{Use idioms for consistency.} Like natural language, programming
languages have idioms, conventional ways that exprerienced programmers
write common pieces of code. A central part of learning any language is
developing a familiarity with its idioms.

One of the most common idioms is the form of a loop. Consider the C, C++,
or Java code for stepping through the \verb'n' elements of an array, for
example to initialize them. Someone might write the loop like this:
\begin{badcode}
    i = 0;
    while (i <= n-1)
        array[i++] = 1.0;
\end{badcode}
or perhaps like this:
\begin{badcode}
    for (i = 0; i < n; )
        array[i++] = 1.0;
\end{badcode}
or even:
\begin{badcode}
    for (i = 0; --i >= 0; )
        array[i] = 1.0;
\end{badcode}
All of these are correct, but the idiomatic form is like this:
\begin{wellcode}
    for (i = 0; i < n; i++)
        array[i] = 1.0;
\end{wellcode}
This is not an arbitrary choice. It visits ecah member of an n-element
array indexed from \verb'0' to \verb'n-1'. It places all the loop control
in the \verb'for' itself, runs in increasing order, and uses the very
idiomatic \verb'++' operator to undate the loop variable. It leaves the
index variable at a known value just beyond the last array element. Native
speakers recognize it which study and write it correctly without a moment's
thought.

In C++ or Java, a common variant includes the declaration of the loop
variable:
\begin{wellcode}
    for (int i = 0; i < n; i++)
        array[i] = 1.0;
\end{wellcode}
Here is the standard loop for walking along a list in C:
\begin{wellcode}
    for (p = list; p != NULL; p = p->next)
        ...
\end{wellcode}
Again, all the loop control is in the \verb'for'.

For an infinite loop, we prefer 
\begin{wellcode}
    for (;;)
        ...
\end{wellcode}
but 
\begin{wellcode}
    while (1)
        ...
\end{wellcode}
is also popular. Don't use anything other than these forms.

Indentation should be idiomatic, too. This unusual vertical layout
detracts(贬低) from readability; it looks like three statements, not a loop:
\begin{badcode}
    for (
        ap = arr;
        ap < arr + 128;
        *ap++ = 0
        )
    {
        ;
    }
\end{badcode}
A standard loop is much easier to read:
\begin{wellcode}
    for (ap = arr; ap < arr+128; ap++)
        *ap = 0;
\end{wellcode}
Sprawling(蔓延的) layout also force code onto multiple screens or pages,
and thus detract from readability.

Another common idiom is to nest an assignment inside a loop condition, as
in 
\begin{wellcode}
    while ((c = getchar()) != EOF)
        putchar(c);
\end{wellcode}
The \verb'do-while' statement is used much less often than \verb'for' and
\verb'while', because it always executes at least once, testing at the
bottom of the loop instead of the top. In many cases, that behavior is a
bug waiting to bite, as in this rewrite of the \verb'getchar' loop:
\begin{badcode}
    do {
        c = getchar();
        putchar(c);
    } while (c != EOF);
\end{badcode}
It write a spurious(假的) output character because the test occurs after
the call to \verb'putchar'. The \verb'do-while' loop is the right one only
when the body of the loop must always be executed at least once; we'll see
some examples later.

One advantage of the consistent use of idioms is that it draws attentions
to non-standard loops, a frequent sign of trouble:
\begin{wellcode}
    int i, *iArray, nmemb;

    iArray = malloc(nmemb * sizeof(int));
    for (i = 0; i <= nmemb; i++)
        iArray[i] = i;
\end{wellcode}
Space is allocated for \verb'nmemb' items, \verb'iArray[0]' through
\verb'iArray[nmemb-1]', but since the loop test is \verb'<=' the loop walks
off the end of array and overwrites whatever is stored next in memory.
Unfortunately, error like this are often not detected until long after the
damage has been done.

C and C++ also have idioms for allocating space for strings and then
manipulating it, and code that doesn't use them often harbors(隐藏) a bug:
\begin{badcode}
    char *p, buf[256];

    gets(buf);
    p = malloc(strlen(buf));
    strcpy(p, buf);
\end{badcode}
One should never use \verb'gets', since there is no way to limit the amount
of input it will read. This leads to security problems that we'll return to
in Chapter \ref{chap:testing}, where we will show that \verb'fgets' is
always a better choice. But there is another problem as well:
\verb'strlen' does not count the \verb"'\0'" that terminates a string,
while \verb'strcpy' copies it. So not enough space is allocated, and
\verb'strcpy' writes past the end of allocated space. The idiom is 
\begin{wellcode}
    p = malloc(strlen(buf) + 1);
    strcpy(p, buf);
\end{wellcode}
or 
\begin{wellcode}
    p = new char[strlen(buf) + 1];
    strcpy(p, buf);
\end{wellcode}
in C++. If you don't see the \verb'+1', bewary.

Java doesn't suffer from this specific problem, since string are not
prepresented as null-terminated arrays. Array substripts are checked as
well, so it is not possible to access outside the bounds of an array in Java.

Most C and C++ environments provide a library function, \verb'strdup', that
creates a copy of a string using \verb'malloc' and \verb'strcpy', making it
easy to avoid this bug. Unfortunately, \verb'strdup' is not part of the
ANSI C standard.

By the way, neither the original code nor the corrected version check the
value returned by \verb'malloc'. We omitted this improvement to focus on
the main point, but in a real program the return value from \verb'malloc',
\verb'realloc', \verb'strdup', or any other allocation routine should
always be checked.

\emph{Use else-ifs for multi-way decisions.} Multi-way decisions are
idiomatically expressed as a chain of \verb'if .. else if .. else', like this:
\begin{wellcode}
    if (condition1)
        statement1
    else if (condition2)
        statement2
    ...
    else if (conditioni)
        statementi
    else 
        default-statement
\end{wellcode}
The \textit{conditions} read from top to bottom; at the first
\textit{condition} that is satisfied, the \textit{statement} that follows
is executed, and then rest of the construct is skipped. The
\textit{statement} part may be a single statement or group of statements
enclosed in braces. The last \verb'else' handles the "default" situation,
where none of the other alternatives was chosen. This trailing(拖尾的)
\verb'else' part may be ommited if there is no action for the default,
although leaving it with an error message may help to catch conditions that
"can't happen".

Align all of the \verb'else' clauses(子句) vertically rather than lining
up(排列) each \verb'else' with the corresponding \verb'if'. Vertial
alignment emphasizes that test are done in sequence and keep them from
marching off(步进, 越来越近) the right side of the page.

A sequence of nested \verb'if' statement is often a warning of
awkward(笨拙的) code, if not outright(显示) errors:
\begin{badcode}
    if (argc == 3)
        if ((find == fopen(argv[1], "r")) != NULL)
            if ((fout = fopen(argv[2], "w")) != NULL) {
                while ((c = getc(find)) != EOF)
                    putc(c, fout);
                fclose(fin); fclose(fout);
            } else 
                printf("Can't open output file %s\n", argv[1]);
        else 
            printf("Can't open input file %s\n", argv[1]);
    else 
        printf("Usage: cp inputfile outputfile\n");
\end{badcode}
The sequence of \verb'if's requires us to maintain a mental(心理的)
pushdown(推进) stack of what tests were make, so that at the appropriate
point we can pop them until we determine the corresponding action (if we
can still remember). Since at most one action will be performed, we really
want an \verb'else if'. Changing the order in which the decisions are made
leads to a clearer version, in which we have also corrected the resource
leak(泄漏) in the original:
\begin{wellcode}
    if (argc != 3)
        printf("Usage: cp inputfile outputfile\n");
    else if ((fin = fopen(argv[1], "r")) == NULL)
        printf("Can't open input file %s\n", argv[1]);
    else if ((fout = fopen(argv[2], "w")) == NULL) {
        printf("Can't open output file %s\n", argv[2]);
        fclose(fin);
    } else {
        while ((c = getc(fin)) != EOF)
            putc(c, fout);
        fclose(fin);
        fclose(fout);
    }
\end{wellcode}
We read down the tests until the first one that is true, do the
corresponding action, and continue after the last \verb'else'. The rule is
to follow each decision as closely as possible by it's associated action.
Or, to put it another way, each time you make a test, do something.

Attempts to re-use pieces of code often lead to tightly knotted(纠缠的) programs.
\begin{badcode}
    switch (c) {
    case '-': sign = -1;
    case '+': c = getchar();
    case '.': break;
    default: if (!isdigit(c))
                return 0;
    }
\end{badcode}
This uses a tricky sequence of fall-throughs in the \verb'switch' statement
to avoid duplicating one line of code. It's also not idiomatic; cases
should almost always end with a \verb'break', with the rare exceptions
commented. A more traditional layout and structure is easier to read,
though longer:
\begin{badcode}
    switch (c) {
    case '-':
        sign = -1;
        /* fall through */
    case '+':
        c = getchar();
        break;
    case '.':
        break;
    default:
        if (!isdigit(c))
            return 0;
        break;
    }
\end{badcode}
The increase in size is more than offset by the increase in clarity.
However, for such an unusual structure, a sequence of \verb'else-if' is
even clearer:
\begin{wellcode}
    if (c == '-') {
        sign = -1;
        c = getchar();
    } else if (c == '+') {
        c = getchar();
    } else if (c != '.' && !isdigit(c)) {
        return 0;
    }
\end{wellcode}
The braces around the one-line blocks highlight the parallel structure.

An acceptable use of a fall-through occurs when several cases have
identical code; the conventional layout is like this:
\begin{wellcode}
    case '0':
    case '1':
    case '2':
        ...
        break;
\end{wellcode}
and no comment is required.

\begin{exercise}
    Rewrite these C/C++ excerpts more clearly:

    \begin{badcode}
        if (istty(stdin)) ;
        else if (istty(stdout)) ;
            else if (istty(stderr)) ;
                else return(0);
    \end{badcode}

    \begin{badcode}
        if (retval != SUCCESS)
            return(retval);
        /* All went well */
        return SUCCESS;
    \end{badcode}

    \begin{badcode}
        for (k = 0; k++ < 5; x += dx)
            scanf("%lf", %dx);
    \end{badcode}
\end{exercise}

\begin{exercise}
    Identify the errors in this Java fragment and repair it by rewriting
    with an idiomatic loop:
    \begin{badcode}
        int count = 0;
        while (count < total) {
            count++;
            if (this.getName(count) == nametable.userName()) {
                return (true);
            }
        }
    \end{badcode}
\end{exercise}
