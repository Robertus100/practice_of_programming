% vim: ts=4 sts=4 sw=4 et tw=75
\chapter{Testing}
\label{chap:testing}
\begin{quote}
    In ordinary computational practice by hand or by desk
% XXX The hyperlink of footnote doesn't response when click.
    mtichines\footnote{Unrecognized word}, it is the custom to check every
    step of the computation and, when an error is found, to localize it by
    a backward process starting from the first point where the error is
    noted.
\end{quote}
\begin{quotesrc}
% XXX The hyperlink of footnote doesn't response when click.
    Norbert Wiener, \bookname{Cybernetics}\footnote{控制论.}
\end{quotesrc}

Testing and debugging are often spoken as a single phrase but they are not
the same thing. To over-simplify, debugging is what you do when you know
that a program is broken. Testing is a determined, systematic attempt to
break a program that you think is working.

Edsger Dijkstra made the famous observation that testing can demonstrate
the presence of bugs, but not their absence. His hope is that programs can
be made correct by construction, so that there are no errors and thus no
need for testing. Though this is a fine goal, it is not yet realistic for
substantial (大量的) programs. So in this chapter we'll focus on how to
test to find errors rapidly, efficiently, and effectively.

Thinking about potential problems as you code is a good start. Systematic
testing, from easy tests to elaborate (详尽的) ones, helps ensure that
programs begin life working correctly and remain correct as they grow.
Automation helps to eliminate manual processes and encourages (促进)
extensive (多方面的) testing. And there are plenty of tricks of the trade
that programmers have learned from experience.

One way to write bug-free code is to generate it by a program. If some
programming task is understood so well that writing the code seems
mechanical, then it should be mechanized (机械化的). A common case occurs
when a program can be generated from a specification in some specialized
language. For example, we compile high-level languages into assembly code;
we use regular expressions to specify patterns of text; we use notations
like \verb'SUM(A1:A50)' to represent operations over a range of cells in a
spreadsheet. In such cases, if the generator or translator is correct and
if the specification is correct, the resulting program will be correct too.
We will cover this rich topic in more detail in Chapter
\ref{chap:notation}; in this chapter we will talk briefly about ways to
create tests from compact specifications.

\section{Test as You Write the Code}
\label{sec:test_as_you_write_the_code}

The earlier a problem is found, the better. If you think systematically
about what you are writing as you write it, you can verify simple
properties of the program as it is being constructed, with the result that
your code will have gone through one round of testing before it is even
compiled. Certain kinds of bugs never come to life.

\emph{Test code at its boundaries.} One technique is \textit{boundary
    condition} testing: as each small piece of code is written -- a loop or
a conditional statement, for example -- check right then that the condition
branches the right way or that the loop goes through the proper number of
times. This process is called boundary condition testing because you are
probing at the natural boundaries within the program and data, such as
non-existent or empty input, a single input item, an exactly full array,
and so on. The idea is that most bugs occur at boundaries. If a piece of
code is going to fail, it will likely fail at a boundary. Conversely
(相反), if it works at its boundaries, it's likely to work elsewhere too.

This fragment, modeled on \verb'fgets', reads characters until it finds a
newline or fills a buffer:
\begin{badcode}
    int     i;
    char    s[MAX];

    for (i = 0; (s[i] = getchar()) != '\n' && i < MAX - 1; ++i)
        ;
    s[--i] = '\0';
\end{badcode}
Imagine that you have just written this loop. Now simulate it mentally as
it reads a line. The first boundary to test is the simplest: an empty line.
If you start with a line that contains only a single newline, it's easy to
see that the loop stops on the first iteration with \verb'i' set to zero,
so the last line decrements \verb'i' to \verb'-1' and thus writes a null
byte into \verb's[-1]', which is before the beginning of the array.
Boundary condition testing finds the error.

If we rewrite the loop to use the conventional idiom for filling an array
with input characters, it looks likes this:
\begin{wellcode}
    for (i = 0; i < MAX - 1; i++)
        if ((s[i] = getchar()) == '\n')
            break;
    s[i] = '\0';
\end{wellcode}
Repeating the original boundary test, it's easy to verify that a line with
just a newline is handled correctly: \verb'i' is zero, the first input
character breaks out of the loop, and \verb"'\0'" is stored in \verb's[0]'.
Similar checking for inputs of one and two characters followed by a newline
give us confidence that the loop works near that boundary.

Boundary condition testing can catch lots of bugs, but not all of them. We
will return to this example in Chapter \ref{chap:portability}, where we
will show that it still has a portability bug.

The next step is to check input at the other boundary, where the array is
nearly full, exactly full, and over-full, particularly if the newline
arrives at the same time.  We won't write out the details here, but it's a
good exercise. Thinking about the boundaries raises the question of what to
do when the buffer fills before a \verb"'\n'" occurs; this gap (缺口) in
the specification should be resolved early, and testing boundaries helps to
identify it.

Boundary condition checking is effective for finding off-by-one (单一断接)
errors.  With practice, it becomes second nature, and many trivial (琐碎的)
bugs are eliminated before they ever happen.

\emph{Test pre- and post-conditions.} Another way to head off (拦截)
problems is to verify that expected or necessary properties hold before
(pre-condition) and after (post-condition) some piece of code executes.
Making sure that input values are within range is a common example of
testing a pre-condition. This function for computing the average of
\verb'n' elements in an array has a problem if \verb'n' is less than or
equal to zero:
\begin{badcode}
    double avg(double a[], int n)
    {
        int     i;
        double  sum;

        sum = 0.0;
        for (i = 0; i < n; i++)
            sum += a[i];
        return sum / n;
    }
\end{badcode}

What should \verb'avg' do if \verb'n' is zero? An array with no elements is
a meaningful concept although its average value is not. Should \verb'avg'
let the system catch the division by zero? Abort? Complain? Quietly return
some innocuous (无害的) value? What if \verb'n' is negative, which is
nonsensical (无意义) but not impossible?  As suggested in Chapter
\ref{chap:interface}, our preference would probably be to return 0 as the
average if \verb'n' is less than or equal to zero:
\begin{wellcode}
    return n <= 0 ? 0.0 : sum/n;
\end{wellcode}
but there's no single right answer.

The one guaranteed wrong answer is to ignore the problem. An article in the
November, 1998 \bookname{Scientific American} describes an incident (事件)
aboard (在...之上) the USS Yorktown, a guided-missile cruiser (导弹巡洋舰).
A crew member mistakenly entered a zero for a data value, which resulted in
a division by zero, an error that cascaded and eventually shut down the
ship's propulsion (推进) system. The Yorktown was dead in the water for a
couple of hours because a program didn't check for valid input.

\emph{Use assertions.} C and C++ provide an assertion facility in
\verb'assert.h' that encourages adding pre- and post-condition tests. Since
a failed assertion aborts the program, these are usually reserved for
situations where a failure is really unexpected and there's no way to
recover. We might augment (增加) the code above with an assertion before
the loop:
\begin{wellcode}
    assert(n > 0);
\end{wellcode}
If the assertion is violated, it will cause the program to abort with a
standard message:
\begin{wellcode}
    Assertion failed: n > 0, file avgtest.c, line 7
    Abort(crash)
\end{wellcode}
Assertions are particularly helpful for validating properties of interfaces
because they draw attention to inconsistencies between caller and callee
and may even indicate who's at fault. If the assertion that \verb'n' is
greater than zero fails when the function is called, it points the finger
(手指) at the caller rather than at \verb'avg' itself as the source of
trouble.  If an interface changes but we forget to fix some routine that
depends on it, an assertion may catch the mistake before it causes real
trouble.

\emph{Program defensively.} A useful technique is to add code to handle
"can't happen" cases, situations where it is not logically possible for
something to happen but (because of some failure elsewhere) it might
anyway. Adding a test for zero or negative array lengths to \verb'avg' was
one example. As another example, a program processing grades might expect
that there would be no negative or huge values but should check anyway:
\begin{wellcode}
    if (grade < 0 || grade > 100) /* can't happen */
        letter = '?';
    else if (grade >= 90)
        letter = 'A';
    else
        ...
\end{wellcode}
This is an example of defensive programming: making sure that a program
protects itself against incorrect use or illegal data. Null pointers, out
of range subscripts, division by zero, and other errors can be detected
early and warned about or deflected (转移).  Defensive programming (no pun
intended (没有双关语意)) might well have caught the zero-divide problem on
the Yorktown.

\emph{Check error returns.} One often-overlooked (常常被忽视的) defense is
to check the error returns from library functions and system calls. Return
values from input routines such as \verb'fread' and \verb'fscanf' should
always be checked for errors, as should any file open call such as
\verb'fopen'. If a read or open fails, computation cannot proceed
correctly.

Checking the return code from output functions like \verb'fprintf' or
\verb'fwrite' will catch the error that results from trying to write a file
when there is no space left on the disk.  It may be sufficient to check the
return value from \verb'fclose', which returns \verb'EOF' if any error
occurred during any operation, and zero otherwise.
\begin{wellcode}
    fp = fopen(outfile, "w");
    while (...)                 /* write output to outfile */
        fprintf(fp, ...);
    if (fclose(fp) == EOF) {    /* any errors? */
        /* some output error occurred */
    }
\end{wellcode}
Output errors can be serious. If the file being written is the new version
of a precious file, this check will save you from removing the old file if
the new one was not written successfully.

The effort of testing as you go is minimal and pays off handsomely
(优厚地).  Thinking about testing as you write a program will lead to
better code, because that's when you know best what the code should do. If
instead you wait until something breaks, you will probably have forgotten
how the code works. Working under pressure, you will need to figure it out
again, which takes time, and the fixes will be less thorough and more
fragile because your refreshed understanding is likely to be incomplete.

\begin{exercise}
    Check out these examples at their boundaries, then fix them as
    necessary according to the principles of style in Chapter
    \ref{chap:style} and the advice in this chapter.
    \begin{enumerate}
        \item This is supposed to compute factorials:
        \begin{badcode}
            int factorial(int n)
            {
                int fac;
                fac = 1;
                while (n--)
                    fac *= n;
                return fac;
            }
        \end{badcode}
        \item This is supposed to print the characters of a string one per
            line:
        \begin{badcode}
            i = 0;
            do {
                putchar(s[i++];
                putchar('\n');
            } while (s[i] != '\0');
        \end{badcode}
        \item This is meant to copy a string from source to destination:
        \begin{badcode}
            void strcpy(char *dest, char *src)
            {
                int i;

                for (i = 0; src[i] != '\0'; i++)
                    dest[i] = src[i];
            }
        \end{badcode}
        \item Another string copy, which attempts to copy \verb'n'
            characters from \verb's' to \verb't':
        \begin{badcode}
            void strncpy(char *s, char *t, int n)
            {
                while (n > 0 && *s != '\0') {
                    *t = *s;
                    t++;
                    s++;
                    n--;
                }
            }
        \end{badcode}
        \item A numerical comparison:
        \begin{badcode}
            if (i > j)
                printf("%d is greater than %d.\n", i, j);
            else
                printf("%d is smaller than %d.\n", i, j);
        \end{badcode}
        \item A character class test:
        \begin{badcode}
            if (c >= 'A' && c <= 'Z') {
                if (c >= 'L')
                    cout << "first half of alphabet";
                else
                    cout << "second half of alphabet";
            }
        \end{badcode}
    \end{enumerate}
\end{exercise}

\begin{exercise}
    As we are writing this book in late 1998, the Year 2000 problem looms
    (若隐若现) as perhaps the biggest boundary condition problem ever.
    \begin{enumerate}
        \item What dates would you use to check whether a system is likely
            to work in the year 2000? Supposing that test are expensive to
            perform, in what order would you do your tests after trying
            January 1, 2000 itself?
        \item How would you test the standard function \verb'ctime', which
            returns a string representation of the date in this form:
        \begin{wellcode}
            Fri Dec 31 23:58:27 EST 1999\n\0
        \end{wellcode}
        Suppose your program calls \verb'ctime'. How would you write your
        code to defend against a flawed (缺陷的) implementation?
        \item Describe how you would test a calendar program that prints
            output like this:
        \begin{wellcode}
             July 2015        
        Su Mo Tu We Th Fr Sa  
                 1  2  3  4  
        5  6  7  8  9  10 11  
        12 13 14 15 16 17 18  
        19 20 21 22 23 24 25  
        26 27 28 29 30 31     
        \end{wellcode}
        \item What other time boundaries can you think of in systems that
            you use, and how would you test to see whether they are handled
            correctly?
    \end{enumerate}
\end{exercise}
