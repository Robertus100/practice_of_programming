% vim: ts=4 sts=4 sw=4 et tw=75
\chapter{Algorithms and Data Structures}
\label{chap:alds}
\begin{quote}
    In the end, only familiarity with the tools and techniques of the field
    will provide right solution for a particular problem, and only a
    certain amount of experience will provide consistently professional
    result.
\end{quote}
\begin{quotesrc}
    Raymond Fielding.\bookname{The Technique of Special Effects
    Cinematography}
\end{quotesrc}
The study of algorithms and data structures is one of the foundations of
computer science, a rich field elegant techniques and sophisticated
mathematical analyses. And it's more than just fun and games for the
theoretically inclined: a good algorithm or data structure might make it
possible to solve a problem in seconds that could otherwise take years.

In specialized areas like graphics, databases, parsing, numerical analysis,
and simulation, the ability to solve problems depends critically on
state-of-the-artalgorithms and data structures. If you are developing your
programs in a field that's new to you, you \textit{must} find out what is
already known, lest (免得) you waste your time doing poorly what others have
already done well.

Every program depends on algorithms and data structures, but few programs
depend on the invention of brand new ones. Even within an intricate
(错综复杂的) program like a compiler or a web browser, most of the data
structures are arrays, lists, trees and hash tables. When a program needs
something more elaborate(详细), it will likely be based on these simpler
ones. Accordingly, for most programmers, the task is to know what
appropriate algorithms and data structures are available and to understand
how to choose among alternatives.

Here is the story in a nutshell. There are only a handful of basic
algorithms that show up in almost every program -- primarily searching and
sorting -- and even those are often included in libraries. Similarly,
almost every data structure is derived from a few fundamental ones. Thus
the material covered in this chapter will be familiar to almost all
programmers. We have written working versions to make the discussion
concrete, and you can lift code verbatim (逐字的) if necessary, but do so
only after you have investigated what the programming language and its
libraries have to offer.

\section{Searching}
Nothing beats an array for storing static tabular data. Compile-time
initialization makes it cheap and easy to construct such arrays. (In Java,
the initialization occurs at run-time, but this is an unimportant
implementation detail unless the arrays are large.) In a program to detect
words that are used rather too much in bad prose, we can write
\begin{wellcode}
    /*lookup: sequential search for word in array */
    int lookup(char *word, char *array[])
    {
        int i;
        for (i = 0; array[i] != NULL; i++)
           if (strcmp(word, array[i] == 0))
                return i;
        return -1;
    }
\end{wellcode}
In C and C++, a parameter that is an array of strings can be declared as
\verb"char *array[]" or \verb"char *+array". Although these forms are
equivalent, the first makes it clearer how the parameter will be used.

This search algorithm is called \textbf{\textit{sequential search}} because
it looks at each element in turn to see if it's the desired one. When the
amount of data is small, sequential search is fast enough. There are
standard library routines to do sequential search for specific data types;
for example, functions like \texttt{strchr} and \texttt{strstr} search for
the first instance of a given character or substring in a C or C++ string.
The Java \verb'String' class has an \verb'indexOf' method, and the generic
C++ \verb'find' algorithms apply to most data types. If such a function
exists for the data type you've got, use it.

Sequential search is easy but the amount of work is directly proportional
to the amount of data to be searched; doubling the number of elements will
double the time to search if the desired item is not present. This is a
linear relationship -- run-time is a linear function of data size -- so
this method is also known as \textbf{\textit{linear search}}.


Here's an excerpt from an array of more realistic size from a program that
parses HTML, which defines textual names for well over a hundred individual
characters:
\begin{wellcode}
    typedef struct Nameval Nameval;
    struct Nameval{
        char *name;
        int value;
    };
    /* HTML characters, e.g. AElig is ligature of A and E. */
    /* Values are Unicode/ISO10646 encoding. */
    Nameval htmlchars[] = {
        "AElig",    0x00c6,
        "Aacute",   0x00c1,
        "Acirc",    0x00c2,
        /* ... */
        "zeta",     0x03b6,
    };
\end{wellcode}
For a larger array like this, it's more efficient to use
\verb'binary' search. The binary search algorithm is an orderly
version of the way we look up words in a dictionary. Check the middle
element. If that value is bigger than what we are looking for, look in the
first half; otherwise, look in the second half. Repeat until the desired
item is found or determined not to be present.

For binary search, the table must be sorted, as it is here (that's good
style anyway; people find things faster in sorted tables too), and we must
know how long the table is. The \verb'NELEMS' macro from Chapter 1 can
help:
\begin{wellcode}
    printf("The HTML table has %d words\n", NELEMS(htmlchars));
\end{wellcode}
A binary search function for this table might look like this:
